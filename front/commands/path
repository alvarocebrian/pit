# Read paths to $_pit_paths variable
declare -A _pit_paths
if [ -f ${PIT_USER_DIRECTORY}/paths ]; then
    while IFS='' read -r line  || [[ -n "$line" ]]; do
        IFS=' ' read -ra line <<< "$line"
        _pit_paths[${line[0]}]=${line[1]}
    done < ${PIT_USER_DIRECTORY}/paths
    unset line
fi

function _pit-path() {
    local subcommand=$1
    shift

    case $subcommand in
        add|edit)
            [ ! $# -eq 2 ] && echo "You must provide two parameters" && _pit-help && return 1
            [ ! -d $2 ] && echo "$2 is not a valid path" && return 1

            _pit_paths[$1]=$2

            truncate ${PIT_USER_DIRECTORY}/paths -s0
            for index in ${!_pit_paths[@]}; do
                echo "$index ${_pit_paths[$index]}" >> ${PIT_USER_DIRECTORY}/paths
            done
        ;;

        rm)
            [ $# -lt 1 ] && echo "You must provide one parameter" && _pit-help && return 1
            unset -v _pit_paths[$1]

            truncate ${PIT_USER_DIRECTORY}/paths -s0
            for index in ${!_pit_paths[@]}; do
                echo "$index ${_pit_paths[$index]}" >> ${PIT_USER_DIRECTORY}/paths
            done
        ;;

        list)
            for index in ${!_pit_paths[@]}; do
                echo "$index: ${_pit_paths[$index]}"
            done
        ;;

        *)
            echo "Usage: pit path <options>"
            echo
            echo "The path command let define some paths for pit"
            echo
            echo "<options>"
            echo "      list                    List all paths defined"
            echo "      add <path_name> <path>  Add a new path to pit"
            echo "      rm <path_name>          Removes the path defined as <path_name>"

        ;;
    esac
}